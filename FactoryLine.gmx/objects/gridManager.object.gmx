<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Define grid size

var s = 48;
width = s;
height = s;

gridWidth = ceil( room_width / width );
gridHeight = ceil( room_height / height );
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create collision grid

gridSolid = ds_grid_create( gridWidth, gridHeight );

enum GridSolid {
    Left = $1 &lt;&lt; 0,
    Top = $1 &lt;&lt; 1,
    Right = $1 &lt;&lt; 2,
    Bottom = $1 &lt;&lt; 3,
    Open = $0
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create object grids

gridBlock = ds_grid_create( gridWidth, gridHeight );
gridItem = ds_grid_create( gridWidth, gridHeight );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Remove the grids

ds_grid_destroy( gridSolid );
ds_grid_destroy( gridBlock );
ds_grid_destroy( gridItem );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset the grids

ds_grid_clear( gridSolid, GridSolid.Open );
ds_grid_clear( gridBlock, noone );
ds_grid_clear( gridItem, noone );
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Include all blocks

var tSolid = gridSolid;
var tGrid = gridBlock;

with ( block ) {
    if ( !active ) continue;
    if ( !gridValidPoint( x, y ) ) continue;
    var tCenterX = gridFromRoomX( x );
    var tCenterY = gridFromRoomY( y );
    for ( var i = 0; i &lt; cellCount; ++i ) {
        var cx = ( tCenterX + cellPosX[i] );
        var cy = ( tCenterY + cellPosY[i] );
        var s = cellSolid[i];
        //Update this cell
        if ( gridValidCell( cx, cy ) ) {
            ds_grid_set( tGrid, cx, cy, id );
            tSolid[# cx, cy] |= s;
        }
        //Update adjacent cells
        if ( ( s &amp; GridSolid.Left ) &amp;&amp; gridValidCell( cx-1, cy ) ) {
            tSolid[# cx-1, cy] |= GridSolid.Right;
        }
        if ( ( s &amp; GridSolid.Right ) &amp;&amp; gridValidCell( cx+1, cy ) ) {
            tSolid[# cx+1, cy] |= GridSolid.Left;
        }
        if ( ( s &amp; GridSolid.Top ) &amp;&amp; gridValidCell( cx, cy-1 ) ) {
            tSolid[# cx, cy-1] |= GridSolid.Bottom;
        }
        if ( ( s &amp; GridSolid.Bottom ) &amp;&amp; gridValidCell( cx, cy+1 ) ) {
            tSolid[# cx, cy+1] |= GridSolid.Top;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check for item collisions

var tSolid = gridSolid;
var tGrid = gridItem;

with ( item ) {
    if ( !gridValidPoint( x, y ) ) continue;
    var tInst, cx, cy;
    
    //Push out of any nearby blocks
    tInst = gridBlockAtPoint( x, y );
    cx = gridFromRoomX( x );
    cy = gridFromRoomY( y );
    //Horizontal
    if ( abs( x - gridToRoomX( cx ) ) &gt; ( other.width - width )/2 ) {
        var tDir = sign( x - gridToRoomX( cx ) );
        var tAdj = gridBlockAtPoint( ( x + tDir*other.width ), y );
        if ( ( $1 &lt;&lt; ( 1 + tDir ) ) &amp; tSolid[# cx, cy] ) {
            x = ( gridToRoomX( cx + tDir/2 ) - tDir*width/2 );
            hspeed = ( min( 0, hspeed * tDir ) * tDir );
            goalX = cx;
        }
    }
    //Vertical
    if ( abs( y - gridToRoomY( cy ) ) &gt; ( other.height - height )/2 ) {
        var tDir = sign( y - gridToRoomY( cy ) );
        var tAdj = gridBlockAtPoint( x, ( y + tDir*other.height) );
        if ( ( $1 &lt;&lt; ( 2 + tDir ) ) &amp; tSolid[# cx, cy] ) {
            y = ( gridToRoomY( cy + tDir/2 ) - tDir*height/2 );
            vspeed = ( min( 0, vspeed * tDir ) * tDir );
        }
    }
    
    //Check for item collisions
    tInst = gridItemAtPoint( x, y );
    if ( instance_exists( tInst ) ) {
        var tNew = instance_create( mean( x, tInst.x ), mean( y, tInst.y ), item );
        tNew.hspeed = mean( hspeed, tInst.hspeed );
        tNew.vspeed = mean( vspeed, tInst.vspeed );
        with ( tInst ) instance_destroy( );
        instance_destroy( );
        ds_grid_set( tGrid, cx, cy, tNew );
    } else {
        ds_grid_set( tGrid, cx, cy, id );
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw gridlines

draw_set_color( c_white );
draw_set_alpha( 1 );

draw_primitive_begin( pr_linelist );

for ( var i = 0; i &lt; gridWidth; ++i ) {
    draw_vertex( i * width, 0 );
    draw_vertex( i * width, room_height );
}

for ( var j = 0; j &lt; gridHeight; ++j ) {
    draw_vertex( 0, j * height );
    draw_vertex( room_width, j * height );
}

draw_primitive_end( );

draw_set_color( c_white );
draw_set_alpha( 1 );
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Fill in object grid cells

draw_set_color( c_white );
draw_set_alpha( 1 );

for ( var i = 0; i &lt; gridWidth; ++i ) {
    for ( var j = 0; j &lt; gridHeight; ++j ) {
        var px = gridToRoomX( i );
        var py = gridToRoomY( j );
        var tTop = gridToRoomY( j - 0.5 );
        var tBottom = gridToRoomY( j + 0.5 );
        var tLeft = gridToRoomX( i - 0.5 );
        var tRight = gridToRoomX( i + 0.5 );
        draw_set_color( c_black );
        if ( instance_exists( gridItemAtPoint( px, py ) ) ) {
            draw_set_color( c_lime );
        } else if ( instance_exists( gridBlockAtPoint( px, py ) ) ) {
            draw_set_color( c_aqua );
        }
        //Draw fill
        if ( draw_get_color( ) != c_black ) {
            draw_rectangle( tLeft, tTop, tRight, tBottom, false );
        }
        //Draw edges
        draw_set_color( c_red );
        var tSolid = gridSolid[# i, j];
        var o = 2;
        if ( tSolid &amp; GridSolid.Top )
            draw_line( tLeft, tTop+o, tRight, tTop+o );
        if ( tSolid &amp; GridSolid.Bottom )
            draw_line( tLeft, tBottom-o, tRight, tBottom-o );
        if ( tSolid &amp; GridSolid.Left )
            draw_line( tLeft+o, tTop, tLeft+o, tBottom );
        if ( tSolid &amp; GridSolid.Right )
            draw_line( tRight-o, tTop, tRight-o, tBottom );
    }
}

draw_set_color( c_white );
draw_set_alpha( 1 );
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
